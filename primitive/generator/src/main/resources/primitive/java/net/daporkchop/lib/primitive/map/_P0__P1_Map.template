$$$settings$$$
{
    "params": [
        {
            "genericName": "K",
            "blacklist": [
                "boolean"
            ]
        },
        {
            "genericName": "V"
        }
    ]
}
_headers_

import net.daporkchop.lib.primitive.collection._P1_Collection;
import net.daporkchop.lib.primitive.lambda.consumer._P0__P1_Consumer;
import net.daporkchop.lib.primitive.lambda.function._P0__P1_Function;
import net.daporkchop.lib.primitive.lambda.function._P0__P1__P1_Function;
import net.daporkchop.lib.primitive.lambda.function._P1__P1__P1_Function;
import net.daporkchop.lib.primitive.set._P0_Set;

/**
 * A group of mappings from unique keys to arbitrary values.
 *
 * @author DaPorkchop_
 */
public interface _P0__P1_Map_gH_ {<1!%
    /**
     * @return the value that will be returned to indicate absence of the corresponding key
     */
    _p1_ defaultValue();

    /**
     * Sets the value that will be returned to indicate absence of the corresponding key.
     * <p>
     * This value is set to {@code _EP1_} by default.
     *
     * @return this {@link _P0__P1_Map}
     */
    _P0__P1_Map_gH_ defaultValue(_p1_ defaultValue);
%>
    /**
     * @return the number of elements in this collection, or {@link Integer#MAX_VALUE} if the size is too large to fit in an {@code int}
     */
    int size();

    /**
     * @return whether or not this collection is empty
     */
    boolean isEmpty();

    /**
     * Checks if the map contains the given key.
     * <p>
     * This function checks for a key that is equal to the given key. What exactly constitutes equality
     * between two keys is up to the implementation to decide, although generally it will check using the
     * {@code ==} operator or {@link Object#equals(Object)}.
     *
     * @param key the key to check for
     * @return whether or not the map contains an equal key
     */
    boolean containsKey(_nameP0_ key);

    /**
     * Checks if the map contains the given value.
     * <p>
     * This function checks for a value that is equal to the given value. What exactly constitutes equality
     * between two values is up to the implementation to decide, although generally it will check using the
     * {@code ==} operator or {@link Object#equals(Object)}.
     * <p>
     * This method will likely require iteration over the entire map.
     *
     * @param value the value to check for
     * @return whether or not the map contains an equal value
     */
    boolean containsValue(_nameP1_ value);

    /**
     * Gets the value mapped to the given key.
     *
     * @param key the key to get the mapped value for
     * @return the value, or <1!%{@link #defaultValue()}%><1%{@code null}%> if a matching entry could not be found
     */
    _p1_ get(_nameP0_ key);

    /**
     * Associates the given value with the given key in this map.
     * <p>
     * If the map previously contained a mapping for the key, the old value is replaced by the given value.
     *
     * @return the value previously mapped to the given key, or <1!%{@link #defaultValue()}%><1%{@code null}%> if it did not previously exist
     */
    _p1_ put(_p0_ key, _p1_ value);

    /**
     * Removes the mapping with the given key from this map.
     *
     * @return the value previously mapped to the given key, or <1!%{@link #defaultValue()}%><1%{@code null}%> if it did not exist
     */
    _p1_ remove(_nameP0_ key);

    /**
     * Copies all of the mappings from the specified map to this map.
     * <p>
     * The result is the same as if {@link #put(_nameP0_, _nameP1_)} were called individually for each mapping in the given map.
     */
    void putAll(@NonNull _P0__P1_Map_Gextends_ m);

    /**
     * Removes all of the mappings from this map.
     */
    void clear();

    /**
     * @return a {@link _P0_Set} view of the keys contained in this map
     */
    _P0_Set_GP0_ keySet();

    /**
     * @return a {@link _P1_Collection} view of the values contained in this map
     */
    _P1_Collection_GP1_ values();

    /**
     * @return a {@link _P0_Set} view of the entries contained in this map
     */
    Set<Entry_gH_> entrySet();

    interface Entry_gH_ {
        /**
         * @return this entry's key
         */
        _p0_ getKey();

        /**
         * @return this entry's value
         */
        _p1_ getValue();

        /**
         * Replaces this entry's value with the given value.
         *
         * @param value the new value
         * @return the old value
         */
        _p1_ setValue(_p1_ value);
    }

    /**
     * Gets the value mapped to the given key.
     *
     * @param key the key to get the mapped value for
     * @return the value, or the given default value if a matching entry could not be found
     */
    default _p1_ getOrDefault(_nameP0_ key, _p1_ defaultValue)  {
        _p1_ v = this.get(key);
        return v == <1!%this.defaultValue()%><1%null%> ? defaultValue : v;
    }

    /**
     * Performs the given action for each entry in this map until all entries have been processed or the action throws an exception.
     */
    default void forEach(@NonNull _P0__P1_Consumer_Gsuper_ action)  {
        for (Entry_gH_ entry : this.entrySet()) {
            _p0_ k;
            _p1_ v;
            try {
                k = entry.getKey();
                v = entry.getValue();
            } catch (IllegalStateException e)   {
                throw new ConcurrentModificationException(e);
            }
            action.accept(k, v);
        }
    }

    /**
     * Replaces each entry's value with the result of invoking the given function on that entry until all entries have been processed or the
     * function throws an exception.
     */
    default void replaceAll(@NonNull _P0__P1__P1_Function_G0super1super1extends_ function) {
        for (Entry_gH_ entry : this.entrySet()) {
            _p0_ k;
            _p1_ v;
            try {
                k = entry.getKey();
                v = entry.getValue();
            } catch (IllegalStateException e)   {
                throw new ConcurrentModificationException(e);
            }
            v = function.apply<1!%As_P1_%>(k, v);
            try {
                entry.setValue(v);
            } catch (IllegalStateException e)   {
                throw new ConcurrentModificationException(e);
            }
        }
    }

    /**
     * Associates the given value with the given key in this map.
     * <p>
     * If the map previously contained a mapping for the key, the old value is returned and the map is not modified.
     *
     * @return the value previously mapped to the given key, or <1!%{@link #defaultValue()}%><1%{@code null}%> if it did not previously exist
     */
    default _p1_ putIfAbsent(_p0_ key, _p1_ value)  {
        _p1_ v = this.get(key);
        return v == <1!%this.defaultValue()%><1%null%> ? this.put(key, value) : v;
    }

    /**
     * Removes the entry for the given key only if it is currently mapped to the given value.
     *
     * @return whether or not the entry was removed
     */
    default boolean remove(_nameP0_ key, _nameP1_ value)    {
        _nameP1_ curValue = this.get(key);
        if (value != curValue) { //TODO: this won't work for objects
            return false;
        }
        this.remove(key);
        return true;
    }

    /**
     * Removes the value for the given key only if it is currently mapped to the given value.
     *
     * @return whether or not the value was replaced
     */
    default boolean replace(_p0_ key, _p1_ oldValue, _p1_ newValue)  {
        _p1_ curValue = this.get(key);
        if (oldValue != curValue) { //TODO: this won't work for objects
            return false;
        }
        this.put(key, newValue);
        return true;
    }

    /**
     * Replaces the value for the given key.
     * <p>
     * If the map did not previously contain a mapping for the key, the map is not modified.
     *
     * @return the value previously mapped to the given key, or <1!%{@link #defaultValue()}%><1%{@code null}%> if it did not previously exist
     */
    default _p1_ replace(_p0_ key, _p1_ value)  {
        _p1_ curValue = this.get(key);
        return curValue == <1!%this.defaultValue()%><1%null%> ? curValue : this.put(key, value);
    }

    /**
     * Gets the value mapped to the given key, computing it using the given function and storing it in the map if absent.
     *
     * @return the value
     */
    default _p1_ computeIfAbsent(_p0_ key, @NonNull _P0__P1_Function_G0super1extends_ mappingFunction)  {
        _p1_ v = this.get(key);
        _p1_ defaultValue = <1!%this.defaultValue()%><1%null%>;
        if (v == defaultValue && (v = mappingFunction.apply<1!%As_P1_%>(key)) != defaultValue)   {
            this.put(key, v);
        }
        return v;
    }

    /**
     * If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value.
     * <p>
     * If the function returns <1!%{@link #defaultValue()}%><1%{@code null}%>, the mapping is removed.
     *
     * @return the new value, or <1!%{@link #defaultValue()}%><1%{@code null}%> if none
     */
    default _p1_ computeIfPresent(_p0_ key, @NonNull _P0__P1__P1_Function_G0super1super1extends_ remappingFunction) {
        _p1_ oldValue = this.get(key);
        _p1_ defaultValue = <1!%this.defaultValue()%><1%null%>;
        if (oldValue != defaultValue)   {
            _p1_ newValue = remappingFunction.apply<1!%As_P1_%>(key, oldValue);
            if (newValue != defaultValue)   {
                this.put(key, newValue);
                return newValue;
            } else {
                this.remove(key);
                return defaultValue;
            }
        } else {
            return defaultValue;
        }
    }

    /**
     * Attempts to compute a mapping for the specified key and its current mapped value (or <1!%{@link #defaultValue()}%><1%{@code null}%> if
     * there is no current mapping).
     * <p>
     * If the function returns <1!%{@link #defaultValue()}%><1%{@code null}%>, the mapping is removed.
     *
     * @return the new value, or <1!%{@link #defaultValue()}%><1%{@code null}%> if none
     */
    default _p1_ compute(_p0_ key, @NonNull _P0__P1__P1_Function_G0super1super1extends_ remappingFunction) {
        _p1_ oldValue = this.get(key);
        _p1_ newValue = remappingFunction.apply<1!%As_P1_%>(key, oldValue);

        _p1_ defaultValue = <1!%this.defaultValue()%><1%null%>;
        if (newValue == defaultValue)   {
            if (oldValue != defaultValue)   {
                this.remove(key);
            }
            return defaultValue;
        } else {
            this.put(key, newValue);
            return newValue;
        }
    }

    /**
     * If the specified key is not already associated with a value, associates it with the given value. Otherwise, replaces the associated
     * value with the results of the given remapping function, or removes it if the result is <1!%{@link #defaultValue()}%><1%{@code null}%>.
     *
     * @return the new value, or <1!%{@link #defaultValue()}%><1%{@code null}%> if none
     */
    default _p1_ merge(_p0_ key, _p1_ value, @NonNull _P1__P1__P1_Function_G1super1super1extends_ remappingFunction) {
        _p1_ oldValue = this.get(key);

        _p1_ defaultValue = <1!%this.defaultValue()%><1%null%>;
        _p1_ newValue = oldValue == defaultValue ? value : remappingFunction.apply<1!%As_P1_%>(oldValue, value);
        if (newValue == defaultValue)   {
            this.remove(key);
        } else {
            this.put(key, newValue);
        }
        return newValue;
    }
}
